---
layout: default
title: 11.10. Tutorial (5a part)
nav_order: 10
parent: 11.10. Tutorial
has_children: false 
---

* Taula de continguts
{:toc}


# Extrendre els repositoris

Com ja has vist, l'objecte `Repository` permet executar consultes senzilles sense pràcticament cap treball:

```php
// from inside a controller
$repository = $this->getDoctrine()->getRepository(Link::class);
$links = $repository->findAll();
```
Els mètodes diponibles són els següents:
 
```php
/**
 * @method Link|null find($id, $lockMode = null, $lockVersion = null)
 * @method Link|null findOneBy(array $criteria, array $orderBy = null)
 * @method Link[]    findAll()
 * @method Link[]    findBy(array $criteria, array $orderBy = null, $limit = null, $offset = null)
 */
```

Però, i si necessitem una consulta més complexa? Quan generem una entitat amb `make:entity`, el comandament també genera una classe anomenada ProductRepository.

```php
// src/Repository/LinkRepository.php
namespace App\Repository;

use App\Entity\Link;
use Doctrine\Bundle\DoctrineBundle\Repository\ServiceEntityRepository;
use Doctrine\Common\Persistence\ManagerRegistry;

class LinkRepository extends ServiceEntityRepository
{
    public function __construct(ManagerRegistry $registry)
    {
        parent::__construct($registry, Product::class);
    }
}

```
Quan obtens el repositori (p.e. `->getRepository(Link::class)`), estàs obtenint realment una instància d'aquest objecte! 

Suposem que vols fer una consulta que obtinga tots els objectes Link amb data posterior a certa data. Hauries d'afegir un nou mètode dins del repositori:

```php
// src/Repository/LinkRepository.php

// ...
class LinkRepository extends ServiceEntityRepository
{
    public function __construct(ManagerRegistry $registry)
    {
        parent::__construct($registry, Product::class);
    }

    /**
     * @return Link[]
     */
    public function findAllAfterDate(DateTime $date): array{
        $query = $this->createQueryBuilder('l')
            ->andwhere("l.createdAt >= :date")
            ->orderBy('l.createdAt', 'DESC')
            ->setParameter('date', $date)
            ->getQuery();

        return $query->getResult();
    }

```


Query Builder, és una forma orientada a objectes d'escriure consultes. Es recomana utilitzar-la quan les consultes es creen dinàmicament.


Ara, pots cridar el mètode del repositori:

```php
// from inside a controller
$date = new DateTime("2020-01-01");

$products = $this->getDoctrine()
    ->getRepository(Link::class)
    ->findAllAfterDate($date);

// ...
```

També es possible utilitzar l'objecte Query, així com executar consultes directament amb PDO.

### Objecte Query ###

```php
   /**
     * @return Link[]
     */
    public function findAllAfterDate(DateTime $date): array{
        $query = $this->createQuery('
            SELECT l
            FROM App\Entity\Link l
            WHERE l.createdAt >= :date
            ORDER BY l.createdAt DESC')
            ->setParameter('date', $date);


        return $query->getResult();
    }
```


### Consultes SQL 


```php
// src/Repository/LinkRepository.php

// ...
public function findAllAfterDate(DateTime $date): array
{
    $conn = $this->getEntityManager()->getConnection();

    $sql = '
        SELECT * FROM link l
        WHERE l.created_at > :date
        ORDER BY l.created_at DESC
        ';
    $stmt = $conn->prepare($sql);
    $stmt->execute(['date' => $date]);

    // returns an array of arrays (i.e. a raw data set)
    return $stmt->fetchAll();
}
```
Aquestes consultes SQL tornen arrays no objectes (a no ser que uses la funcionalitat [NativeQuery](https://www.doctrine-project.org/projects/doctrine-orm/en/latest/reference/native-sql.html)).


Més informació en [Querying for objects the repository](https://symfony.com/doc/current/doctrine.html#querying-for-objects-the-repository)


# Recursos
https://anil.io/blog/symfony/doctrine/symfony-and-doctrine-pagination-with-twig/

